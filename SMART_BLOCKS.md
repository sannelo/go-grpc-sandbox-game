# Система умных блоков для Go gRPC игрового сервера

## Обзор архитектуры

Мы реализовали архитектуру умных блоков для 2D песочницы с процедурной генерацией. Эта система позволяет блокам иметь сложное поведение, взаимодействовать с игроками и другими блоками, а также изменять свое состояние с течением времени.

### Ключевые компоненты системы:

1. **Интерфейсы блоков**:
   - `Block` - базовый интерфейс для всех блоков
   - `DynamicBlock` - для блоков, которые меняются со временем
   - `InteractiveBlock` - для блоков, с которыми можно взаимодействовать

2. **BlockManager**:
   - Управляет всеми блоками в мире
   - Организует планирование обновлений динамических блоков
   - Обрабатывает взаимодействие игроков с интерактивными блоками
   - Эмиттирует события изменения блоков

3. **Система активных чанков**:
   - Чанки с динамическими блоками помечаются как активные
   - Активные чанки не выгружаются из памяти при очистке кеша
   - Эффективное управление памятью при больших мирах

4. **Компонентное устройство блоков**:
   - Все блоки имеют базовую реализацию (`BaseBlock`)
   - Специализированное поведение реализуется в конкретных классах
   - Свойства блоков хранятся в карте для гибкости

5. **Поддержка хранения**:
   - Сериализация/десериализация состояния блоков
   - Поддержка сохранения в бинарное хранилище

## Реализованные типы блоков

### Динамические блоки:
- **Огонь (FireBlock)**:
  - Интенсивность пламени меняется со временем
  - Имеет ограниченное время жизни
  - Может распространяться на соседние блоки

- **Растения (CropBlock)**:
  - Растут с течением времени
  - Требуют влаги для роста
  - Имеют несколько стадий развития

### Интерактивные блоки:
- **Дверь (DoorBlock)**:
  - Открывается/закрывается при взаимодействии
  - Может быть заблокирована владельцем
  - Владелец может разрешать/запрещать доступ

- **Сундук (ChestBlock)**:
  - Хранит предметы в инвентаре
  - Поддерживает добавление/извлечение предметов
  - Может быть заблокирован владельцем

## Протокол взаимодействия с блоками

1. **Типы взаимодействия**:
   - `use`: базовое использование (открыть дверь, открыть сундук)
   - `lock`/`unlock`: блокировка/разблокировка
   - `putItem`/`getItem`: операции с инвентарем

2. **События блоков**:
   - `BLOCK_CHANGED`: состояние блока изменилось
   - `BLOCK_INTERACTION`: произошло взаимодействие с блоком
   - `BLOCK_TICK`: периодическое обновление блока

## План дальнейших действий

### 1. Генерация кода из proto-файла
Необходимо сгенерировать Go-код из обновленного proto-файла для поддержки новых типов сообщений и полей.

```bash
protoc --go_out=plugins=grpc:. proto/game/game.proto
```

### 2. Расширение BlockManager
- Реализовать распространение огня между блоками
- Добавить поддержку более сложных взаимодействий между блоками

### 3. Расширение иерархии блоков
- Добавить новые типы динамических блоков (текущая вода, лава)
- Добавить новые типы интерактивных блоков (печь, верстак)

### 4. Оптимизация производительности
- Реализовать пространственное разделение для оптимизации обновлений
- Ввести уровни приоритета для обновления чанков
  - Высокий приоритет: чанки рядом с игроками
  - Средний приоритет: чанки с активными процессами
  - Низкий приоритет: удаленные чанки с медленными процессами

### 5. Оптимизация хранения
- Эффективное сохранение состояния динамических блоков
- Инкрементальные обновления для блоков с часто меняющимся состоянием

### 6. Расширение возможностей клиента
- Обновить клиентский код для поддержки взаимодействия с блоками
- Реализовать UI для интерактивных блоков

### 7. Тестирование производительности
- Провести нагрузочное тестирование с большим количеством динамических блоков
- Оптимизировать узкие места в системе обновления блоков

## Потенциальные проблемы и их решения

1. **Высокая нагрузка на CPU при большом количестве динамических блоков**:
   - Реализовать многоуровневое планирование обновлений
   - Группировать обновления блоков одного типа
   - Использовать подход "ленивых вычислений"

2. **Высокий сетевой трафик при обновлении блоков**:
   - Реализовать батчинг обновлений
   - Приоритизировать обновления по важности
   - Использовать дельта-сжатие для передачи изменений

3. **Проблемы с сериализацией сложных состояний**:
   - Реализовать специализированные сериализаторы для сложных блоков
   - Использовать эффективные форматы (protobuf, messagepack)

4. **Рассинхронизация состояния между сервером и клиентами**:
   - Реализовать периодическую полную синхронизацию
   - Ввести версионирование состояний блоков
   - Реализовать механизм разрешения конфликтов

## Заключение

Реализованная система умных блоков предоставляет мощный фундамент для создания разнообразного интерактивного игрового мира. Она обеспечивает хорошую производительность и масштабируемость, позволяя легко добавлять новые типы блоков с минимальными изменениями в коде.

Компонентная архитектура и четкое разделение ответственности между модулями упрощает поддержку и расширение кодовой базы. Система событий обеспечивает слабую связанность компонентов и повышает устойчивость к ошибкам. 